"""Functions which define the fields in the lockfile's metadata header.

New fields can be added to the MetadataFields class.
"""

import os
import shlex
import sys

from datetime import datetime
from getpass import getuser
from typing import List, Optional

from pkg_resources import get_distribution

from conda_lock.src_parser import LockSpecification


class MetadataFields:
    """All fields which can be selected to appear in the lockfile's metadata header.

    To add a new field, simply define a method of the desired field name with no
    arguments other than self. It will be automatically detected as a valid field,
    so no further registration steps are necessary.

    Any helper methods or (static) class attributes should be prefixed with a '_'
    character so that they won't be detected as fields.
    """

    def __init__(self, spec: LockSpecification, comment: Optional[str]):
        """Here we pass in data to be accessed, and set corresponding instance
        attributes.
        """
        self.spec = spec
        self.comment_str = comment

    def about(self) -> str:
        """A message explaining that this file was created with conda-lock."""
        return "This lockfile was generated by conda-lock to ensure reproducibility."

    def platform(self) -> str:
        """The plaform of a given lockfile, e.g. 'linux-64'."""
        return self.spec.platform

    def created_by(self) -> Optional[str]:
        """The username at the time of running the command."""
        try:
            return getuser()
        except (KeyError, AttributeError):
            return None

    def timestamp(self) -> datetime:
        """The time at which the lock was created."""
        return datetime.now().replace(microsecond=0).astimezone()

    def command_with_path(self) -> str:
        """The command used to invoke the lock, after being processed by the shell."""
        return argv_to_string(sys.argv)

    def command(self) -> str:
        """Same as 'command_with_path` but with the path to the executable stripped."""
        argv = sys.argv.copy()
        argv[0] = os.path.basename(argv[0])
        return argv_to_string(argv)

    def conda_lock_version(self) -> str:
        """The conda-lock version used to make this lockfile."""
        return get_distribution("conda_lock").version

    def input_hash(self) -> str:
        """A SHA-256 hash of the lock file input specification."""
        return self.spec.input_hash()

    def comment(self) -> Optional[str]:
        """A textual comment passed as a command-line argument."""
        if self.comment_str is None:
            return None
        return LiteralStr(self.comment_str)


METADATA_FIELDS_LIST = [
    field for field in dir(MetadataFields) if not field.startswith("_")
]
"""List of the public methods defined in MetadataFieldFunctions."""

METADATA_FIELDS_LIST_AS_STRING = "'" + "', '".join(METADATA_FIELDS_LIST) + "'"
"""Looks something like:
    'about', 'command', ..., 'timestamp'
"""


def argv_to_string(argv: List[str]) -> str:
    """Take a list of command-line arguments and escape them to a shell command.

    This is a helper function for 'command' and 'command_with_path'.
    """
    return _escape_newlines_for_bash(" ".join(shlex.quote(arg) for arg in argv))


def _escape_newlines_for_bash(s: str) -> str:
    r"""This is a helper function for 'argv_to_string()'.

    We want to replace newline characters with:
      $'\n'
    But a newline character triggers shlex's single-quote mode, and thus can only
    occur therein. Therefore we actually need surrounding single quotes around the
    above string in order to exit and reenter single-quote mode. The actual substitution
    rule we need is thus:
      '$'\n''
    """
    if "\n" in s:
        print(
            r"WARNING: There are newlines appearing in the 'command' metadata field. "
            r"They will be escaped for Bash as $'\n' but since you're doing something "
            r"complicated, consider instead explaining your command with something "
            r"like --comment=$(README.txt)",
            file=sys.stderr,
        )
    return s.replace("\n", r"'$'\n''")


class LiteralStr(str):
    """This is a trivial extension of the 'str' class which indicates to our PyYAML
    Dumper class that the corresponding string should be formatted as a block literal.
    """

    pass
